/**
 * Aptly API
 * The swiss army knife for Debian repository management
 *
 * OpenAPI spec version: 0.9.7
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as models from '../model/models';

/* tslint:disable:no-unused-variable member-ordering */

export class DefaultApi {
    protected basePath = 'http://localhost:8080/api';
    public defaultHeaders : any = {};

    static $inject: string[] = ['$http', '$httpParamSerializer', 'basePath'];

    constructor(protected $http: ng.IHttpService, protected $httpParamSerializer?: (d: any) => any, basePath?: string) {
        if (basePath !== undefined) {
            this.basePath = basePath;
        }
    }

    /**
        * Deletes all files in upload directory and directory itself.
        * 
        * @param dir directory name
        */
    public filesDirDelete (dir: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/files/{dir}'
            .replace('{' + 'dir' + '}', String(dir));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'dir' is not null or undefined
        if (dir === null || dir === undefined) {
            throw new Error('Required parameter dir was null or undefined when calling filesDirDelete.');
        }
        let httpRequestParams: ng.IRequestConfig = {
            method: 'DELETE',
            url: localVarPath,
                                    params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
        * Delete single file in directory.
        * 
        * @param dir directory name
        * @param file file name
        */
    public filesDirFileDelete (dir: string, file: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/files/{dir}/{file}'
            .replace('{' + 'dir' + '}', String(dir))
            .replace('{' + 'file' + '}', String(file));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'dir' is not null or undefined
        if (dir === null || dir === undefined) {
            throw new Error('Required parameter dir was null or undefined when calling filesDirFileDelete.');
        }
        // verify required parameter 'file' is not null or undefined
        if (file === null || file === undefined) {
            throw new Error('Required parameter file was null or undefined when calling filesDirFileDelete.');
        }
        let httpRequestParams: ng.IRequestConfig = {
            method: 'DELETE',
            url: localVarPath,
                                    params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
        * Returns list of files in directory.
        * 
        * @param dir directory name
        */
    public filesDirGet (dir: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<Array<string>> {
        const localVarPath = this.basePath + '/files/{dir}'
            .replace('{' + 'dir' + '}', String(dir));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'dir' is not null or undefined
        if (dir === null || dir === undefined) {
            throw new Error('Required parameter dir was null or undefined when calling filesDirGet.');
        }
        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
                                    params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
        * Parameter {dir} is upload directory name. Directory would be created if it doesnâ€™t exist.
        * Any number of files can be uploaded in one call, aptly would preserve filenames. No check is performed if existing uploaded would be overwritten. 
        * @param dir directory name
        * @param file file to upload
        */
    public filesDirPost (dir: string, file: any, extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/files/{dir}'
            .replace('{' + 'dir' + '}', String(dir));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'dir' is not null or undefined
        if (dir === null || dir === undefined) {
            throw new Error('Required parameter dir was null or undefined when calling filesDirPost.');
        }
        // verify required parameter 'file' is not null or undefined
        if (file === null || file === undefined) {
            throw new Error('Required parameter file was null or undefined when calling filesDirPost.');
        }
        headerParams['Content-Type'] = 'application/x-www-form-urlencoded';

        formParams['file'] = file;

        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
                        data: this.$httpParamSerializer(formParams),
            params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
        * List all directories.
        * 
        */
    public filesGet (extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/files';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
                                    params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
        * Show information about package by package key.
        * 
        * @param key package key (unique package identifier)
        */
    public packagesKeyGet (key: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/packages/{key}'
            .replace('{' + 'key' + '}', String(key));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling packagesKeyGet.');
        }
        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
                                    params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
        * List published repositories.
        * 
        */
    public publishGet (extraHttpRequestParams?: any ) : ng.IHttpPromise<Array<models.PublishedRepository>> {
        const localVarPath = this.basePath + '/publish';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
                                    params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
        * Publish local repository or snapshot without prefix
        * 
        * @param asdf 
        */
    public publishPost (asdf: models.PublishRepository, extraHttpRequestParams?: any ) : ng.IHttpPromise<models.PublishedRepository> {
        const localVarPath = this.basePath + '/publish';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'asdf' is not null or undefined
        if (asdf === null || asdf === undefined) {
            throw new Error('Required parameter asdf was null or undefined when calling publishPost.');
        }
        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
            data: asdf,
                        params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
        * Delete published repository, clean up files in published directory.
        * 
        * @param prefix 
        * @param distribution 
        * @param force 
        */
    public publishPrefixDistributionDelete (prefix: string, distribution: string, force?: number, extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/publish/{prefix}/{distribution}'
            .replace('{' + 'prefix' + '}', String(prefix))
            .replace('{' + 'distribution' + '}', String(distribution));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'prefix' is not null or undefined
        if (prefix === null || prefix === undefined) {
            throw new Error('Required parameter prefix was null or undefined when calling publishPrefixDistributionDelete.');
        }
        // verify required parameter 'distribution' is not null or undefined
        if (distribution === null || distribution === undefined) {
            throw new Error('Required parameter distribution was null or undefined when calling publishPrefixDistributionDelete.');
        }
        if (force !== undefined) {
            queryParameters['force'] = force;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'DELETE',
            url: localVarPath,
                                    params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
        * Update published local repo/Switch published snapshot
        * API action depends on published repository contents;  * if local repository has been published, published repository would be updated to match local repository contents  * if snapshots have been been published, it is possible to switch each component to new snapshot 
        * @param prefix 
        * @param distribution 
        * @param asdf 
        */
    public publishPrefixDistributionPut (prefix: string, distribution: string, asdf?: models.PublishedRepositoryUpdate, extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/publish/{prefix}/{distribution}'
            .replace('{' + 'prefix' + '}', String(prefix))
            .replace('{' + 'distribution' + '}', String(distribution));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'prefix' is not null or undefined
        if (prefix === null || prefix === undefined) {
            throw new Error('Required parameter prefix was null or undefined when calling publishPrefixDistributionPut.');
        }
        // verify required parameter 'distribution' is not null or undefined
        if (distribution === null || distribution === undefined) {
            throw new Error('Required parameter distribution was null or undefined when calling publishPrefixDistributionPut.');
        }
        let httpRequestParams: ng.IRequestConfig = {
            method: 'PUT',
            url: localVarPath,
            data: asdf,
                        params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
        * Publish local repository or snapshot under specified prefix.
        * Storage might be passed in prefix as well, e.g. s3:packages/.
        * @param prefix 
        * @param asdf 
        */
    public publishPrefixPost (prefix: string, asdf: models.PublishRepository, extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/publish/{prefix}'
            .replace('{' + 'prefix' + '}', String(prefix));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'prefix' is not null or undefined
        if (prefix === null || prefix === undefined) {
            throw new Error('Required parameter prefix was null or undefined when calling publishPrefixPost.');
        }
        // verify required parameter 'asdf' is not null or undefined
        if (asdf === null || asdf === undefined) {
            throw new Error('Required parameter asdf was null or undefined when calling publishPrefixPost.');
        }
        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
            data: asdf,
                        params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
        * Show list of currently available local repositories.
        * 
        */
    public reposGet (extraHttpRequestParams?: any ) : ng.IHttpPromise<Array<models.Repository>> {
        const localVarPath = this.basePath + '/repos';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
                                    params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
        * Delete local repository.
        * Local repository canâ€™t be deleted if it is published. If local repository has snapshots, aptly would refuse to delete it by default, but that can be overridden with force flag. 
        * @param name 
        * @param force 
        */
    public reposNameDelete (name: string, force?: number, extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/repos/{name}'
            .replace('{' + 'name' + '}', String(name));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling reposNameDelete.');
        }
        if (force !== undefined) {
            queryParameters['force'] = force;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'DELETE',
            url: localVarPath,
                                    params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
        * Import packages from files to the local repository
        * Import packages from files (uploaded using File Upload API) to the local repository. If directory specified, aptly would discover package files automatically.  Adding same package to local repository is not an error.  By default aptly would try to remove every successfully processed file and directory :dir (if it becomes empty after import). 
        * @param name 
        * @param dir 
        * @param file 
        * @param noRemove when value is set to 1, donâ€™t remove any files
        * @param forceReplace when value is set to 1, remove packages conflicting with package being added (in local repository)
        */
    public reposNameFileDirFilePost (name: string, dir: string, file: string, noRemove?: number, forceReplace?: number, extraHttpRequestParams?: any ) : ng.IHttpPromise<models.ImportResult> {
        const localVarPath = this.basePath + '/repos/{name}/file/{dir}/{file}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'dir' + '}', String(dir))
            .replace('{' + 'file' + '}', String(file));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling reposNameFileDirFilePost.');
        }
        // verify required parameter 'dir' is not null or undefined
        if (dir === null || dir === undefined) {
            throw new Error('Required parameter dir was null or undefined when calling reposNameFileDirFilePost.');
        }
        // verify required parameter 'file' is not null or undefined
        if (file === null || file === undefined) {
            throw new Error('Required parameter file was null or undefined when calling reposNameFileDirFilePost.');
        }
        if (noRemove !== undefined) {
            queryParameters['noRemove'] = noRemove;
        }

        if (forceReplace !== undefined) {
            queryParameters['forceReplace'] = forceReplace;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
                                    params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
        * Import packages from files to the local repository
        * Import packages from files (uploaded using File Upload API) to the local repository. If directory specified, aptly would discover package files automatically.  Adding same package to local repository is not an error.  By default aptly would try to remove every successfully processed file and directory :dir (if it becomes empty after import). 
        * @param name 
        * @param dir 
        * @param noRemove when value is set to 1, donâ€™t remove any files
        * @param forceReplace when value is set to 1, remove packages conflicting with package being added (in local repository)
        */
    public reposNameFileDirPost (name: string, dir: string, noRemove?: number, forceReplace?: number, extraHttpRequestParams?: any ) : ng.IHttpPromise<models.ImportResult> {
        const localVarPath = this.basePath + '/repos/{name}/file/{dir}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'dir' + '}', String(dir));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling reposNameFileDirPost.');
        }
        // verify required parameter 'dir' is not null or undefined
        if (dir === null || dir === undefined) {
            throw new Error('Required parameter dir was null or undefined when calling reposNameFileDirPost.');
        }
        if (noRemove !== undefined) {
            queryParameters['noRemove'] = noRemove;
        }

        if (forceReplace !== undefined) {
            queryParameters['forceReplace'] = forceReplace;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
                                    params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
        * Returns basic information about local repository.
        * 
        * @param name 
        */
    public reposNameGet (name: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<models.Repository> {
        const localVarPath = this.basePath + '/repos/{name}'
            .replace('{' + 'name' + '}', String(name));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling reposNameGet.');
        }
        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
                                    params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
        * Remove packages from local repository by package keys.
        * 
        * @param name 
        * @param asdf 
        */
    public reposNamePackagesDelete (name: string, asdf: models.PackageKeys, extraHttpRequestParams?: any ) : ng.IHttpPromise<models.Repository> {
        const localVarPath = this.basePath + '/repos/{name}/packages'
            .replace('{' + 'name' + '}', String(name));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling reposNamePackagesDelete.');
        }
        // verify required parameter 'asdf' is not null or undefined
        if (asdf === null || asdf === undefined) {
            throw new Error('Required parameter asdf was null or undefined when calling reposNamePackagesDelete.');
        }
        let httpRequestParams: ng.IRequestConfig = {
            method: 'DELETE',
            url: localVarPath,
            data: asdf,
                        params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
        * List all packages in local repository or perform search on repository contents and return result.
        * 
        * @param name 
        * @param q package query, if missing - return all packages
        * @param withDeps set to 1 to include dependencies when evaluating package query
        * @param format result format, compact by default (only package keys), details to return full information about each package (might be slow on large repos)
        */
    public reposNamePackagesGet (name: string, q?: string, withDeps?: number, format?: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/repos/{name}/packages'
            .replace('{' + 'name' + '}', String(name));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling reposNamePackagesGet.');
        }
        if (q !== undefined) {
            queryParameters['q'] = q;
        }

        if (withDeps !== undefined) {
            queryParameters['withDeps'] = withDeps;
        }

        if (format !== undefined) {
            queryParameters['format'] = format;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
                                    params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
        * Add packages to local repository by package keys.
        * Any package could be added, it should be part of aptly database (it could come from any mirror, snapshot, other local repository). This API combined with package list (search) APIs allows to implement importing, copying, moving packages around.  API verifies that packages actually exist in aptly database and checks constraint that conflicting packages canâ€™t be part of the same local repository. 
        * @param name 
        * @param asdf 
        */
    public reposNamePackagesPost (name: string, asdf: models.PackageKeys, extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/repos/{name}/packages'
            .replace('{' + 'name' + '}', String(name));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling reposNamePackagesPost.');
        }
        // verify required parameter 'asdf' is not null or undefined
        if (asdf === null || asdf === undefined) {
            throw new Error('Required parameter asdf was null or undefined when calling reposNamePackagesPost.');
        }
        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
            data: asdf,
                        params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
        * Update local repository meta information.
        * 
        * @param name 
        * @param repo 
        */
    public reposNamePut (name: string, repo: models.RepositoryUpdate, extraHttpRequestParams?: any ) : ng.IHttpPromise<models.Repository> {
        const localVarPath = this.basePath + '/repos/{name}'
            .replace('{' + 'name' + '}', String(name));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling reposNamePut.');
        }
        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposNamePut.');
        }
        let httpRequestParams: ng.IRequestConfig = {
            method: 'PUT',
            url: localVarPath,
            data: repo,
                        params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
        * Create snapshot of current local repository :name contents as new snapshot with name {snapname}.
        * 
        * @param name 
        * @param snapshot 
        */
    public reposNameSnapshotsPost (name: string, snapshot: models.SnapshotUpdate, extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/repos/{name}/snapshots'
            .replace('{' + 'name' + '}', String(name));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling reposNameSnapshotsPost.');
        }
        // verify required parameter 'snapshot' is not null or undefined
        if (snapshot === null || snapshot === undefined) {
            throw new Error('Required parameter snapshot was null or undefined when calling reposNameSnapshotsPost.');
        }
        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
            data: snapshot,
                        params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
        * Create empty local repository with specified parameters.
        * 
        * @param repo asdf
        */
    public reposPost (repo: models.Repository, extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/repos';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposPost.');
        }
        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
            data: repo,
                        params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
        * Return list of all snapshots created in the system.
        * 
        * @param sort snapshot order, defaults to name, set to time to display in creation order
        */
    public snapshotsGet (sort?: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<Array<models.Snapshot>> {
        const localVarPath = this.basePath + '/snapshots';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
                                    params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
        * Delete snapshot.
        * Snapshot canâ€™t be deleted if it is published. aptly would refuse to delete snapshot if it has been used as source to create other snapshots, but that could be overridden with force parameter. 
        * @param name 
        * @param force 
        */
    public snapshotsNameDelete (name: string, force?: number, extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/snapshots/{name}'
            .replace('{' + 'name' + '}', String(name));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling snapshotsNameDelete.');
        }
        if (force !== undefined) {
            queryParameters['force'] = force;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'DELETE',
            url: localVarPath,
                                    params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
        * Calculate difference between two snapshots :name (left) and :withSnapshot (right).
        * 
        * @param name 
        * @param withSnapshot 
        */
    public snapshotsNameDiffWithSnapshotGet (name: string, withSnapshot: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<Array<models.PackageDiff>> {
        const localVarPath = this.basePath + '/snapshots/{name}/diff/{withSnapshot}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'withSnapshot' + '}', String(withSnapshot));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling snapshotsNameDiffWithSnapshotGet.');
        }
        // verify required parameter 'withSnapshot' is not null or undefined
        if (withSnapshot === null || withSnapshot === undefined) {
            throw new Error('Required parameter withSnapshot was null or undefined when calling snapshotsNameDiffWithSnapshotGet.');
        }
        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
                                    params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
        * Get information about snapshot by name.
        * 
        * @param name 
        */
    public snapshotsNameGet (name: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<models.Snapshot> {
        const localVarPath = this.basePath + '/snapshots/{name}'
            .replace('{' + 'name' + '}', String(name));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling snapshotsNameGet.');
        }
        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
                                    params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
        * List all packages in snapshot or perform search on snapshot contents and return result.
        * 
        * @param name 
        * @param q 
        * @param withDeps 
        * @param format 
        */
    public snapshotsNamePackagesGet (name: string, q?: string, withDeps?: number, format?: string, extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/snapshots/{name}/packages'
            .replace('{' + 'name' + '}', String(name));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling snapshotsNamePackagesGet.');
        }
        if (q !== undefined) {
            queryParameters['q'] = q;
        }

        if (withDeps !== undefined) {
            queryParameters['withDeps'] = withDeps;
        }

        if (format !== undefined) {
            queryParameters['format'] = format;
        }

        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
                                    params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
        * Update snapshot&#39;s description or name.
        * 
        * @param name 
        * @param asdf 
        */
    public snapshotsNamePut (name: string, asdf: models.SnapshotUpdate, extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/snapshots/{name}'
            .replace('{' + 'name' + '}', String(name));

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling snapshotsNamePut.');
        }
        // verify required parameter 'asdf' is not null or undefined
        if (asdf === null || asdf === undefined) {
            throw new Error('Required parameter asdf was null or undefined when calling snapshotsNamePut.');
        }
        let httpRequestParams: ng.IRequestConfig = {
            method: 'PUT',
            url: localVarPath,
            data: asdf,
                        params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
        * Create snapshot from list of package references.
        * This API creates snapshot out of any list of package references. Package references could be obtained from other snapshots, local repos or mirrors.  Sending request without SourceSnapshots and PackageRefs would create empty snapshot. 
        * @param asdf 
        */
    public snapshotsPost (asdf: models.SnapshotFromPackageRefs, extraHttpRequestParams?: any ) : ng.IHttpPromise<{}> {
        const localVarPath = this.basePath + '/snapshots';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        // verify required parameter 'asdf' is not null or undefined
        if (asdf === null || asdf === undefined) {
            throw new Error('Required parameter asdf was null or undefined when calling snapshotsPost.');
        }
        let httpRequestParams: ng.IRequestConfig = {
            method: 'POST',
            url: localVarPath,
            data: asdf,
                        params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
    /**
        * Return current aptly version.
        * 
        */
    public versionGet (extraHttpRequestParams?: any ) : ng.IHttpPromise<models.Version> {
        const localVarPath = this.basePath + '/version';

        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let httpRequestParams: ng.IRequestConfig = {
            method: 'GET',
            url: localVarPath,
                                    params: queryParameters,
            headers: headerParams
        };

        if (extraHttpRequestParams) {
            httpRequestParams = (<any>Object).assign(httpRequestParams, extraHttpRequestParams);
        }

        return this.$http(httpRequestParams);
    }
}
